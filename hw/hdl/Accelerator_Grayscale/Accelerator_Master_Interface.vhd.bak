-- Accelerator_Master_Interface.vhd
--
-- Authors : Guilhem Azzano and Pierre Fourcade

--------------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- ENTITY ----------------------------------------------------------------------------

entity Master_DMA_Mirror_Swap is
	GENERIC(	REG_DELAY : natural := 0);
	PORT   (	Clk    : in std_logic;
				nReset : in std_logic;
				-- Master interface - Avalon Bus
				avm_WaitRequest   : in  std_logic;
				avm_ReadData      : in  std_logic_vector(31 downto 0);
				avm_WriteData     : out std_logic_vector(31 downto 0);
				avm_Read          : out std_logic;
				avm_Write         : out std_logic;
				avm_Address       : out std_logic_vector(31 downto 0);
				avm_ByteEnable    : out std_logic_vector(3  downto 0);
				-- Master interface - Slave interface
				Enable         : in  std_logic;
				Address        : in  std_logic_vector(31 downto 0);
				Length_Address : in  std_logic_vector(31 downto 0);
				Done           : out std_logic;
				Capture_Read   : out std_logic;
				Capture_Write  : out std_logic;
				Data_Read      : out std_logic_vector(31 downto 0);
				Data_Write     : out std_Logic_vector(31 downto 0));
end entity Master_DMA_Mirror_Swap;

--------------------------------------------------------------------------------------

-- ARCHITECTURE ----------------------------------------------------------------------

architecture Behavioral of Master_DMA_Mirror_Swap is
	
	-- State declarations
	type state is (Init, Copy, Read_State, Processing, Write_State, Done_State);
	signal state_reg, state_next : state;
	
	-- Register declarations
	signal Add_reg, Add_next   : unsigned(31 downto 0);
	signal Data_reg, Data_next : std_logic_vector(31 downto 0);
	
	BEGIN

		-------------------------------------------------------------------
		
		Next_State_Logic : process(state_reg, Enable, avm_WaitRequest, Add_reg, Address, Length_Address)
		
			begin
				
				state_next <= state_reg;
				case state_reg is
					-- Init --------------------
					when Init =>
						if Enable = '1' then state_next <= Copy; end if;
					-- Copy --------------------
					when Copy =>
						state_next <= Read_State;
					-- Read_State --------------
					when Read_State =>
						if avm_WaitRequest = '0' then state_next <= Processing; end if;
					-- Processing --------------
					when Processing =>
						state_next <= Write_State;
					-- Write_State -------------
					when Write_State =>
						if avm_WaitRequest = '0' then
							if Add_reg = unsigned(Address) + unsigned(Length_Address) then 
								state_next <= Done_State;
							else
								state_Next <= Read_State;
							end if;
						end if;
					-- Done_State --------------------
					when Done_State =>
						if Enable = '0' then state_next <= Init; end if;
					-- Others ------------------
					when others => 
						null;
				end case;
										
		end process Next_State_Logic;
					
		-------------------------------------------------------------------			

		Register_Logic : process(Clk, nReset)
		
			begin
			
				if nReset = '0' then
					state_reg <= Init;
					Add_reg   <= (others => '0');
					Data_reg  <= (others => '0');
				elsif rising_edge(clk) then
					state_reg <= state_next after REG_DELAY*ns;
					Add_reg   <= Add_next   after REG_DELAY*ns;
					Data_reg  <= Data_next  after REG_DELAY*ns;
				end if;
		
		end process Register_Logic;

		-------------------------------------------------------------------
		
		Combinational_Logic : process(state_reg, Add_reg, Data_reg, avm_WaitRequest, avm_ReadData, Address, Length_Address)
		
			begin
				
				Add_next       <= Add_reg;
				Data_next      <= Data_reg;
				avm_WriteData  <= (others => '0');
				avm_Read       <= '0';
				avm_Write      <= '0';
				avm_Address    <= (others => '0');
				avm_ByteEnable <= (others => '0');
				Done           <= '0';
				Capture_Read   <= '0';
				Capture_Write  <= '0';
				Data_Read      <= (others => '0');
				Data_Write     <= (others => '0');
				case state_reg is
					-- Init --------------------
					when Init =>
						Add_next <= (others => '0');
					-- Copy --------------------
					when Copy =>
						Add_next <= unsigned(Address);
					-- Read_State --------------
					when Read_State =>
						avm_Read       <= '1';
						avm_Address    <= std_logic_vector(Add_reg);
						avm_ByteEnable <= "1111";
						if avm_WaitRequest = '0' then
							Data_next    <= avm_ReadData;
							Capture_Read <= '1';
							Data_Read    <= avm_ReadData;
						end if;
					-- Processing ---------------
					when Processing =>
						Data_next(31 downto 24) <= Data_reg(7  downto 0);
						for i in 8 to 23  loop
							Data_next(i) <= Data_reg(31-i);
						end loop;
						Data_next(7  downto 0)  <= Data_reg(31 downto 24);
					-- Write_State --------------
					when Write_State =>
						avm_WriteData  <= Data_reg;
						avm_Write      <= '1';
						avm_Address    <= std_logic_vector(Add_reg);
						avm_ByteEnable <= "1111";
						Capture_Write  <= '1';
						Data_Write     <= Data_reg;
						if avm_WaitRequest = '0' then
							if Add_reg < unsigned(Address) + unsigned(Length_Address) then
								Add_next <= Add_reg + 4;
							end if;
						end if;
					-- Done_State --------------------
					when Done_State =>
						Done <= '1';
					-- Others ------------------
					when others => 
						null;
				end case;
				
		end process Combinational_Logic;
		
		-------------------------------------------------------------------
				
end architecture Behavioral;